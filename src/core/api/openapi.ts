import { Router, Request, Response } from 'express';
import { existsSync, readFileSync, writeFileSync, mkdirSync } from 'fs';
import { join, dirname } from 'path';
import * as yaml from 'js-yaml';
import { execSync } from 'child_process';
import swaggerUiExpress from 'swagger-ui-express';
import { appConfig } from '../index.js';
import fs from 'fs/promises';

/**
 * OpenAPI specification response interface
 */
export interface OpenAPISpecResponse {
  openapi: string;
  info: {
    title: string;
    version: string;
    description?: string;
  };
  servers?: Array<{
    url: string;
    description: string;
  }>;
  paths: Record<string, any>;
  components?: {
    schemas?: Record<string, any>;
    securitySchemes?: Record<string, any>;
  };
  tags?: Array<{
    name: string;
    description: string;
  }>;
}

/**
 * Swagger UI configuration interface
 */
export interface SwaggerUIConfig {
  customCss?: string;
  customSiteTitle?: string;
  customfavIcon?: string;
  swaggerOptions?: {
    persistAuthorization?: boolean;
    displayRequestDuration?: boolean;
    docExpansion?: string;
    defaultModelsExpandDepth?: number;
    urls?: Array<{
      name: string;
      url: string;
    }>;
  };
}

/**
 * Generate OpenAPI specification on-demand using tsoa CLI
 */
function generateSpecOnDemand (specPath: string): void {
  try {
    // Ensure directory exists
    const specDir = dirname(specPath);
    if (!existsSync(specDir)) {
      mkdirSync(specDir, { recursive: true });
    }

    // Try to use tsoa CLI first
    try {
      execSync('npx tsoa spec', {
        cwd: process.cwd(),
        encoding: 'utf8',
        stdio: 'pipe'
      });

      if (existsSync(specPath)) {
        console.log('OpenAPI specification generated successfully via tsoa');
        return;
      }
    } catch (_tsoaError) {
      console.warn('tsoa spec generation failed, creating fallback spec');
    }

    // Create fallback OpenAPI specification
    const fallbackSpec: OpenAPISpecResponse = {
      openapi: '3.0.0',
      info: {
        title: 'MCP Server API',
        version: appConfig.version || '1.0.0',
        description: 'REST API for your MCP Server. This specification is automatically generated.',
      },
      servers: buildServersArray(),
      paths: {
        '/api/health': {
          get: {
            summary: 'Health check',
            description: 'Simple health check endpoint for monitoring',
            tags: ['Server'],
            responses: {
              '200': {
                description: 'Service is healthy',
                content: {
                  'application/json': {
                    schema: {
                      type: 'object',
                      properties: {
                        status: { type: 'string' },
                        timestamp: { type: 'string' },
                        version: { type: 'string' }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      tags: [
        { name: 'Server', description: 'Server management endpoints' },
      ]
    };

    writeFileSync(specPath, yaml.dump(fallbackSpec), 'utf8');
    console.log('Fallback OpenAPI specification created successfully');

  } catch (error: any) {
    throw new Error(`Failed to generate OpenAPI spec: ${error.message}`);
  }
}

/**
 * Automatically configures and serves OpenAPI documentation for APIs with tsoa decorators
 *
 * This function:
 * 1. Detects if OpenAPI spec exists (generated by tsoa)
 * 2. Creates OpenAPI and Swagger UI routes automatically
 * 3. Serves documentation when apiRouter is provided
 *
 * @param apiRouter - Express router with tsoa-decorated endpoints
 * @returns Object with swaggerSpecs and swaggerUi middleware, or null if apiRouter not provided
 */
export function configureOpenAPI (apiRouter?: Router | null): {
  swaggerSpecs?: any;
  swaggerUi?: any;
} | null {
  if (!apiRouter) {
    return null;
  }

  try {
    // Try to load the generated OpenAPI spec
    const specPath = join(process.cwd(), 'swagger/openapi.yaml');

    if (!existsSync(specPath)) {
      // Generate OpenAPI spec on-demand if it doesn't exist
      console.log('OpenAPI specification not found. Generating on-demand...');
      try {
        generateSpecOnDemand(specPath);
      } catch (error) {
        console.warn('Failed to generate OpenAPI specification:', error);
        return null;
      }
    }

    // Load OpenAPI spec
    const specContent = readFileSync(specPath, 'utf8');
    let openAPISpec: OpenAPISpecResponse;

    try {
      // Try YAML first (tsoa default)
      openAPISpec = yaml.load(specContent) as OpenAPISpecResponse;
    } catch {
      // Fallback to JSON
      openAPISpec = JSON.parse(specContent) as OpenAPISpecResponse;
    }

    // Enhance spec with dynamic configuration
    const enhancedSpec = enhanceOpenAPISpec(openAPISpec);

    // Create OpenAPI documentation routes
    createOpenAPIRoutes(apiRouter, enhancedSpec);

    // Return swagger-compatible objects for backward compatibility
    return {
      swaggerSpecs: enhancedSpec,
      swaggerUi: createSwaggerUIMiddleware(enhancedSpec),
    };

  } catch (error) {
    console.error('Failed to configure OpenAPI documentation:', error);
    return null;
  }
}

/**
 * Enhances the OpenAPI specification with dynamic configuration
 */
function enhanceOpenAPISpec (spec: OpenAPISpecResponse): OpenAPISpecResponse {
  const enhanced = { ...spec };

  // Update info from app config
  enhanced.info = {
    ...spec.info,
    title: 'MCP Server API',
    version: appConfig.version || '1.0.0',
  };

  // Build servers array from config with fallback
  enhanced.servers = buildServersArray();

  // Add default security scheme if auth is configured
  if (appConfig.webServer?.auth?.enabled) {
    enhanced.components = enhanced.components || {};
    enhanced.components.securitySchemes = {
      bearerAuth: {
        type: 'http',
        scheme: 'bearer',
        bearerFormat: 'JWT',
        description: 'JWT authorization token',
      },
      ...enhanced.components.securitySchemes,
    };
  }

  return enhanced;
}

/**
 * Builds servers array from configuration
 */
function buildServersArray (): Array<{ url: string; description: string }> {
  const servers = [];

  // Use servers from config if available
  if (appConfig.swagger?.servers?.length) {
    appConfig.swagger.servers.forEach((server: any) => {
      servers.push({
        url: server.url,
        description: server.description,
      });
    });
  } else {
    // Fallback to default development server
    servers.push({
      url: `http://localhost:${appConfig.webServer.port}`,
      description: 'Development server',
    });
  }

  return servers;
}

/**
 * Creates OpenAPI documentation routes on the provided router
 */
function createOpenAPIRoutes (router: Router, spec: OpenAPISpecResponse): void {
  // OpenAPI specification endpoint
  router.get('/openapi.json', (req: Request, res: Response) => {
    res.json(spec);
  });

  router.get('/openapi.yaml', (req: Request, res: Response) => {
    res.type('application/yaml').send(yaml.dump(spec));
  });
}

/**
 * Creates Swagger UI middleware function
 */
function createSwaggerUIMiddleware (spec: OpenAPISpecResponse) {
  const swaggerUiConfig: SwaggerUIConfig = {
    customSiteTitle: `${spec.info.title} Documentation`,
    customCss: '.swagger-ui .topbar { display: none }',
    swaggerOptions: {
      persistAuthorization: true,
      displayRequestDuration: true,
      docExpansion: 'list',
      defaultModelsExpandDepth: 2,
      urls: [
        {
          name: 'API Specification',
          url: '/api/openapi.json',
        },
      ],
    },
  };

  return swaggerUiExpress.setup(spec, swaggerUiConfig);
}

/**
 * Serve Swagger UI static assets
 */
export function createSwaggerUIAssetsMiddleware () {
  return swaggerUiExpress.serve;
}
